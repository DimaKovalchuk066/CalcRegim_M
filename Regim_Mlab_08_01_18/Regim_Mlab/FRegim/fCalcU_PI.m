function [Umod, dU] = fCalcU_PI(g, I, Z, Uop, Nop)
% Функция осуществляет расчет напряжений в узлах по заданным токам ветвей,
% сопротивлениям участков, напряжению опорного узла.
%
% [Umod, dU] = fCalcU_PI(g, I, Z, Uop, Nop)
%
% g - граф расчетной подсхемы, представленный объектом типа CGraph;
% I - структура векторов (ссылок) токов ветвей;
% I.I1 - вектор действительной составляющей тока ветви;
% I.I2 - вектор мнимой составляющей тока ветви;
% Z - структура векторов (ссылок) сопротивлений ветвей;
% Z.R - вектор активного сопротивления ветви;
% Z.X - вектор реактивного сопротивления ветви;
% Uop - структура, представляющая напряжение опорного узла;
% Uop.mod - модуль напряжения опорного узла;
% Uop.d - фаза напряжения опорного узла;
% Nop - номер опорного узла;
% Umod - вектор модулей расчитанных напряжений;
% dU - вектор фаз расчитанных напряжений;
%
% Written by D. Kovalchuk
% Research group of energetic faculty,
% department of BNTU.
% November 2017.

% инициализация массивов для хранения исходных данных
I1=I.I1(':');
I2=I.I2(':');
U(g.nod.n)=complex(0);
Umod(g.nod.n,1)=0;
dU(g.nod.n,1)=0;
R=Z.R(':');
X=Z.X(':');
U1(g.nod.n)=0;
U2(g.nod.n)=0;
% определение действиетльной и мнимой составляющей напряжения опорного узла
U1(Nop)=Uop.mod.*cos(Uop.d);
U2(Nop)=Uop.mod.*sin(Uop.d);
Sign(g.nod.n)=0;
Sign(Nop)=1;

% Инициализация очереди первый вошел первый вышел, определяющей порядок
% обхода узлов
Queue=FIFO;
Queue=add(Queue,Nop);
while(isempty(Queue)==0)
    % текущий узел - первый в очереди обхода
    CurrN=Queue.last; 
    AN=g.nod(CurrN).an;
    AR=g.nod(CurrN).ar;
    % перебор всех узлов, отходящих от текущего
    for J=1:length(AN)
        % если не были в данном узле
        if (Sign(AN(J))==0) 
             % добавиление отходящего узла в очередь
            Queue=add(Queue, AN(J));
            % определение падение напряжения на ветви
            dU1 = (I1(AR(J)) * R(AR(J)) - I2(AR(J)) * X(AR(J)))/1000;
            dU2 = (I1(AR(J)) * X(AR(J)) + I2(AR(J)) * R(AR(J)))/1000;
            % определение знака падения напряжения в соответствии с
            % направлением ветви
            if g.rib(AR(J)).ny1==CurrN
                Sign(AN(J))=1;
            else
                Sign(AN(J))=(-1);
            end
            % определение напряжения отходящего узла
            U1(AN(J))=U1(CurrN)-dU1*Sign(AN(J));
            U2(AN(J))=U2(CurrN)-dU2*Sign(AN(J));
        end
    end
    clear AN AR dU1 dU2;
    % вычеркиваем первый элемент в очереди
    Queue=del(Queue); 
end
    U=U1+1i*U2;
    Umod=(abs(U))';
    dU=(angle(U))';
end